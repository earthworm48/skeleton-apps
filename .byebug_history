c
params
c
BCrypt::Password.new(digest).is_password?(token)
token = @user.reset_token
BCrypt::Password.new(digest).is_password?(token)
digest = @user.reset_digest
digest = self.reset_digest
@user.reset_token
c
BCrypt::Password.new(digest).is_password?(token)
digest = self.reset_digest
token = self.reset_token
self.reset_token
self
@user
exit
@user.remember_token
@user.password_digest
@user.password_token
@user.activation_digest
@user.activation_token
token = @user.activation_token
BCrypt::Password.new(digest).is_password?(token)
digest = @user.reset_digest
token = @user.reset_token
@user.reset_token
@user.reset_digest
@user.email
@user
exit
token
BCrypt::Password.new(digest).is_password?(token)
BCrypt::Password.new(digest).is_password?
BCrypt::Password.new(digest)
user
@user
digest
token
BCrypt::Password.new(digest).is_password?(token)
digest.nil?
digest
c
@user.authenticated?(:reset, params[:id])
@user = User.find_by(email: params[:email])
exit
@user.authenticated?(:reset, params[:id])
BCrypt::Password.new(:reset_digest).is_password?(token)
BCrypt::Password.new(reset_digest).is_password?(token)
BCrypt::Password.new(digest).is_password?(token)
token = params[:id]
digest = "reset_digest"
digest = reset_digest
params[:id]
@user.authenticated?(:reset, params[:id])
@user = User.find_by(email: params[:email])
    assert_match CGI::escape(user.email), mail.body.encoded
    # to find the params[:email]
    assert_match user.activation_token, mail.body.encoded
    assert_match user.name, mail.body.encoded
    assert_equal ["from@example.com"], mail.from
    assert_equal [user.email], mail.to
    assert_equal "Account activation", mail.subject
    mail = UserMailer.account_activation(user)
    user.activation_token = User.new_token
    user = users(:michael)
 test "account_activation" do
exit
params
exit
@user.reset_digest
@user.rest_digest
@user
exit
User.first
 @user = User.find_by(email: params[:password_reset][:email].downcase)
params[:password_reset][:email]
params
exit
edit_account_activation_path(user.activation_token, email: user.email)
user.activation_token
user.email
user
exit
c
params
user
user.activated?
c
user.activated?
c
user.activated?
user
exit
User.where(activated: true).paginate(page: params[:page])
a
User.where(activated: true).paginate(page: params[:page])
User.paginate(page:params[:page]).where(activated: true)
User.paginate(page:params[:page]).find_by(activated: true)
User.find_by(activated: true).paginate(page: params[:page])
User.find_by(actovated: true).paginate(page: params[:page])
activated_user.paginate(page: params[:page])
activated_user.paginate(page: params[:page)
activated_user = User.find_by(activated: true)
User.find_by(activated: true)
User.find_by(:activated, true)
exit
@user
@user.remember
remember(@user)
@user
exit
c
attribute.class
exit
attribute.class
attribute
exit
params
c
exit
logged_in?
c
session[:forwarding_url]
c
session[:forwarding_url]
c
session[:forwarding_url]
request.get?
c
request.get?
request.url
session[:forwarding_url]
c
n
c
request.url
request.get?
c
defined?(options)
defined?(redirect_to)
defined?(if)
defined?(follow_redirect)
defined?(follow_redirect!)
defined?(post_via_redirect)
defined(post_via_redirect)
defined(redirect_to)
integration_test?
exit
params[:session][:remember_me] == '0'
params[:session][:remember_me] == 0
params[:session][:remember_me] == 1
params[:session][:remember_me]
params[:sessions][:remember_me]
params
exit
c
self.remember_token
remember_token
User.new_token
c
remember user
exit
self
exit
session(:user_id)
session
session.delete(:user_id)
params
user_id
exit
Bcrypt::Password.create(string, cost: cost)
c
exit
Bcrypt::Password.create(string, cost: cost)
